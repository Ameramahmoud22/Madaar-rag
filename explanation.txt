                Mini RAG "Retrieval Augmented Generation "system with WebSocket streaming in Django

المشروع ده عبارة عن:
"شات بوت زي ChatGPT بس بيجاوب من ملف PDF اللي احنا رفعناه"
يعني:

اليوزر بيعمل login *
 بيرفع PDF (مثلاً كتاب، تقرير، عقد...) **
 البوت بيفهم محتوى الـ PDF ده***
لما نساله سؤال -> بيجيب الإجابة من الـ PDF مش من معرفته العامة
والإجابة بتيجلنا كلمات منفصلة (streaming) زي ChatGPT ما بيعمل بالضبط

ده اسمه RAG = Retrieval Augmented Generation
يعني: نجيب (Retrieve) المعلومة من الـ PDF، وبعدين نولد (Generate) إجابة باستخدام LLM


***************************************************************************************************
Creating project Steps :
1- Add in required apps: rest_framework, authtoken, channels, rag
2- Add media folder for PDF uploads on [settings.py] file 


3- Set template directory
4- Enable TokenAuthentication

5- Ran migrations
6- Created superuser (amera/amera123)

7- Create login endpoint that returns authentication token and Use Django built-in TokenAuthentication

8.1-  PDF Upload (Part 1)
- Create UploadPDFView with MultiPartParser
- Validate that file exists and is PDF
- Save the uploaded PDF to media directory
- return success Response if uploaded successfully 

8.2- PDF Processing (part 2)
- Extracte text from PDF using PyPDF2 and Handle empty PDF with error response 
- Split text into chunks (1000 chars, 200 overlap) using the built in [RecursiveCharacterTextSplitter]
- Create OpenAI embeddings Built FAISS vector store and saved locally

9- Development Media Serving
- Adde static() for MEDIA_URL in rag_system/urls.py
- This allows accessing uploaded PDFs directly in browser during development
- Only active when DEBUG=True (standard Django practice)
- Not needed in production
*******************************************************************************************************************************************************************************************************************
                            Some important explanations to the rag views.py file 
1- global vectorstore => بيخلّي المتغير vectorstore يتعرف عليه من بره الفانكشن عشان الـ WebSocket بعدين يقدر يقرأ منه بدون ما يعمل واحد جديد 

2-  file = request.FILES.get('file') => بياخد الملف من الـ request  لأن الملفات بتتبعت في FILES مش في data 

3-  التحقق من وجود الملف وإنه PDF لابد من الخطوة دى لانها حماية أساسية طبعا

4-  os.makedirs(os.path.dirname(file_path), exist_ok=True) =>  بيعمل فولدر pdfs لو مش موجود ودى احد ال enhancments علشان ميعملش error لو الفولدر مش موجود

4-  with open() ... file.chunks  بيحفظ الملف فى شكل اجزاء او قطع صغيرة علشان لو انت رفعت ملف كبير ميعملش لود على الميمورى ويحمله كله فيها 

5- PdfReader(file_path) =>  بيفتح ال PDF ويقدر يقرأ منه باستخدام  مكتبة PyPDF2  

6- page.extract_text() => بيطلّع الtext من كل صفحة أحيانًا بيطلع None لو الصفحة صورة بس مثلا او فاضيه  عشان كده بنعمل if
6.2-  if not text.strip =>  لو ال PDF فاضي أو كله صور مثلا بنرفضه او نطلع ايرور انه مفهوش نص

7-  RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200) => بيقطّع النص لقطع صغيرة عشان ال LLM يقدر يفهم السياق كويس 

8-  OpenAIEmbeddings() => بيحوّل كل قطعةاو جزء قطعناه فوق لرقم كبير (vector 1536 رقم) وده اللي بيفهم بيه الكمبيوتر معنى الكلام زى ما احنا عارفين

9- FAISS.from_texts(chunks, embeddings) => بيعمل زى داتابيز بس سريعة جدًا من ال vectors وبتكون أسرع بكتير من انك تسيرش في النص العادي قبل ما تحول ل vector

10- vectorstore.save_local("vectorstore") => بيحفظ الدابيز دى على الديسك بتاعك في فولدر اسمه vectorstore اللى عملناه فى الاول فوق عشان الـ WebSocket يقدر يحمّله تاني من غير ما يعمل واحد جديد زى ما شرحنا

11-  return Response({...}) => بيرجع JSON واضح 

*******************************************************************************************************************************************************************************************************************
                           Why using redis with WebSocket??
*******************************************************************************************************************************************************************************************************************

                           Important Points in asgi.py file 
1- import rag.routing => بنجيب منه عنوان أل WebSocket (ws/chat/)
    
2- get_asgi_application() => ده اللي هيشغل اما ال API والـ admin 

3- ProtocolTypeRouter => من اسمه يعنى هيوديك على البروتوكول المناسب بناء على انت عايز اى زي حارس البوابة بتاع المشروع، بيقول:
 * لو الطلب http => روح للـ Django العادي 
 * لو الطلب websocket => روح للـ Channels


4- AuthMiddlewareStack → ده اللى بيحدد الصلاحيات بقا:
بيشوف اليوزر مسجل دخول ولا لأ
 * لو مسجل => يدخله الشات
* لو مش مسجل => يقفله فورًا


5- URLRouter(rag.routing.websocket_urlpatterns) → ده اللى هيشوف في ملف routing.py ويشوف إيه عنوان الشات

                                           باختصار شديد :
          ده الملف اللى خلّى المشروع يفهم ال WebSocket + يحميه من ان اى شخص unlogined انه يستخد الشات اللى اتعمل 

*******************************************************************************************************************************************************************************************************************
                                       Important Points in routing.py file  

1- ده زي urls.py بس للـ WebSocket يعني لما حد يكتب في المتصفح:
ws://127.0.0.1:8000/ws/chat/
Django Channels هيروح يبص في الملف ده ويفح ال

*******************************************************************************************************************************************************************************************************************

                                       Important Points in consumer.py file  

1- import json => عشان نحول البيانات لـ JSON ونبعتها للفرونت

2- import asyncio => عشان أقدر أعمل await وأبعت الكلام كلمة كلمة بدون ما السيرفر يقف

3- from channels.generic.websocket import AsyncWebsocketConsumer => ده الكلاس الأساسي اللي بنعمل منه الـ WebSocket في Django Channels

4- from .rag_logic import get_rag_response => دي الفانكشن اللي هتجيب الرد من الـ PDF بتاع اليوزر وليها فايل فيه اللوجيك بتاعها

5- بعدها عملنا كلاس ChatConsumer وده بيورث من AsyncWebsocketConsumer علشان يكون Async زيه

                                             ***
7- async def connect(self):
   ده بيشتغل أول ما حد يفتح ال WebSocket (يعني لما الفرونت يعمل new WebSocket)

7- self.scope["user"] => ده بيجيب اليوزر اللي متصل دلوقتي (باستخدام AuthMiddlewareStack اللي في asgi.py)
   7.1- if self.scope["user"].is_anonymous: => لو اليوزر مش مسجل دخول (يعني anonymous)
      7.2-  await self.close() => اقفل الاتصال فورًا وما تكملش ( "Unauthenticated users must not be able to access")
  7.3 - await self.accept() => لو مسجل دخول => اقبل الاتصال
   7.4 - وبعدين بعتله رسالة ترحيب باسمه عشان يعرف إن كل حاجة شغالة

                                         ***
8-async def receive(self, text_data):
   ده بيشتغل كل ما اليوزر يبعت رسالة من الفرونت

8.1- json.loads(text_data) => بحول الرسالة من string ل dictionary

8.2- query = data.get("message", "") => بجيب النص اللي كتبه اليوزر 

8.3- لو الرسالة فاضية → خلاص ما تعملش حاجة

8.4- أول حاجة بعتناله رسالة "Searching on your PDF" (زي ChatGPT بالظبط لما بيقول thinking)
     علشان  نحسسه إن في حاجة بتحصل

8.5- full_response = await get_rag_response(...) 
     => هنا بروح أجيب الرد الكامل من ال RAG بتاع اللي رفع ال PDF بتاعه وده هيوضح فى الفايل بتاع rag_logic

                                        ***
9- بعد كده عملنا لوب على كل كلمه بعد ما عملنالها split 

9.1- await self.send(...) => ببعت كل كلمة لوحدها

9.2- await asyncio.sleep(0.04) => بستنى ثانية ربع ثانية بين كل كلمة علشان يبان زي الكتابة الحقيقية

                                       ***
10- في الآخر بعتله رسالة {"type": "done"} علشان الفرونت يعرف إن الرد خلص

                                      ***
                             الخلاصة بتاع الفايل ده

   -اليوزر بيشوف الرد يطلع كلمة كلمة زي ChatGPT بالظبط
                   - لو مش مسجل دخول → الشات يتقفل فورًا
- كل يوزر بيشوف الـ PDF بتاعه هو بس (مش بتاع حد تاني) 
*****************************************************************************************************










*****************************************************************************************************

My superuser :
user = amera
email = ameraelbassal552005@gmail.com
pass = amera123
******************************************************************************


